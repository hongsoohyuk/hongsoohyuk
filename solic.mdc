---
alwaysApply: true
---

# SOLID Principles for Frontend (React + TypeScript)

## 1. SRP (Single Responsibility Principle) - 단일 책임 원칙

### 핵심 개념

> 하나의 클래스나 모듈은 변경되어야 할 이유가 단 하나여야 한다.

### 실무 요약

- “하나의 기능만 수행해야 한다”가 아니라 “변경 이유가 하나여야 한다.”
- UI, 데이터 fetch, 포맷팅, 로깅 등을 한 컴포넌트에 몰아넣지 말 것.

### React 적용 전략

- **Custom Hook**: 비즈니스 로직 분리 (ex. useProducts, useProductSearch)
- **Service Layer**: API 호출, analytics, storage 분리
- **Utility 함수**: 포맷팅, 계산, 검증 로직 따로 관리
- **Container / Presentational 분리**: 데이터 관리 vs UI 책임 분리

---

## 2. OCP (Open-Closed Principle) - 개방-폐쇄 원칙

### 핵심 개념

> 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.

### 실무 요약

- 새 기능 추가 시 기존 코드를 수정하지 않아야 함.
- 조건문 기반 분기 대신 설정 객체나 컴포지션 사용.

### React 적용 전략

- **Strategy Pattern**: 설정 기반 확장
- **Composition Pattern**: `Modal.Header`, `Modal.Body` 같은 compound component
- **Render Props / Compound Components**: 수정 없이 기능 합성 가능하게 설계
- **Plugin Architecture**: 확장 가능한 구조를 설계

---

## 3. LSP (Liskov Substitution Principle) - 리스코프 치환 원칙

### 핵심 개념

> 하위 타입은 상위 타입을 대체할 수 있어야 한다.

### 실무 요약

- 부모 인터페이스를 구현한 모든 하위 타입이 동일한 계약을 지켜야 함.
- 예상치 못한 예외나 동작 불일치는 LSP 위반.

### React 적용 전략

- **Props 일관성 유지**: 동일한 역할의 컴포넌트는 동일한 props 인터페이스 사용
- **동일한 에러 처리 규약** 유지
- **테스트 기반 검증**: 구현체 교체 시 테스트 통과해야 함
- 예시: `TextFormField`, `EmailFormField`, `PasswordFormField` 등 동일한 props로 교체 가능해야 함

---

## 4. ISP (Interface Segregation Principle) - 인터페이스 분리 원칙

### 핵심 개념

> 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 된다.

### 실무 요약

- 하나의 거대한 props/interface 대신, 기능별로 작게 쪼갠다.
- 재사용성과 테스트 용이성을 높인다.

### React 적용 전략

- **Props 분리**: `TableDataProps`, `TablePaginationProps`, `TableSortProps` 등 세분화
- **Context 분리**: Auth, Theme, Cart 등 별도 Context 관리
- **Pick / Omit** 활용**:** TypeScript로 필요한 속성만 조합
- **필요한 부분만 조합형 props로 전달**

---

## 5. DIP (Dependency Inversion Principle) - 의존성 역전 원칙

### 핵심 개념

> 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다.

### 실무 요약

- 컴포넌트가 axios, localStorage, toast 등 **구체 구현체**에 직접 의존하지 않도록 한다.
- 인터페이스 기반 추상화를 두고, Context/Provider로 주입.

### React 적용 전략

- **Service Interface 정의**:
  - `HttpClient`, `StorageService`, `NotificationService` 등
- **Provider 주입**:
  - `ServiceContext.Provider`로 구현체를 외부에서 주입
- **Custom Hook 캡슐화**:
  - `useOrders`, `useServices` 등에서 내부 구현을 숨기기
- **환경별 구현체 교체** 가능 (테스트용 Mock, 개발용 콘솔 로그 등)

---

## 실무 체크리스트

✅ SRP — 하나의 컴포넌트/함수/모듈은 하나의 역할만 수행해야 한다.
✅ OCP — 기능 확장은 허용하되 기존 코드의 직접 수정은 최소화해야 한다.
✅ LSP — 상위 타입을 사용하는 곳에서 하위 타입으로 대체가 가능해야 한다. 구현체를 바꿔도 같은 동작을 보장해야한다.
✅ ISP — 지나치게 많은 props나 옵션을 가진 컴포넌트는 분리해야 한다.
✅ DIP — 구현이 아닌 추상화(core types/interfaces)에 의존해야 한다.
